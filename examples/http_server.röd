record HttpServer {
	port : number
	socket : Server
	controllers : map<Controller> = new map<Controller>
	
	/* Luku */
	
	function read connection &request {
		request := new Request
		request.server = self
		request.connection = connection
		connection.read -l line
		things := !(split line)
		if test #things -ge 3; do
			request.command = things[0]
			request.path = things[1]
			request.protocol = things[2]
			request.protocol ~= "\r?\n$" ""
		else
			/* kysely on väärän muotoinen */
			/* TODO: virheenkäsittely */
			request.valid = ![false]
			connection.close
			return
		done
		request.path ~= "^([a-z0-9]+://)?[^/]+" ""
		length := 0
		request.headers = new map<string>
		request.as_text = ""
		while test line -not_matches "\r?\n"; do
			request.as_text .= line
			connection.read -l line
			if test line -matches "[A-Za-z\\-]+:[ \t]*.*\r?\n"; do
				header_name := line
				header_name ~= ":[ \t]*.*\r?\n$" ""
				header_value := line
				header_value ~= "^[A-Za-z\\-]+:[ \t]*" "" "\r?\n$" ""
				request.headers[header_name] = header_value
			done
			if test line -matches "Content-Length: .*\r?\n"; do
				cl := line
				cl ~= "^Content-Length: " "" "\r?\n$" ""
				length = cl
			done
		done
		request.content = ""
		if test length -gt 0; do
			content := ""
			connection.read -b length content
			request.content = content
		done
		request.form = new map<string>
		if push request.headers["Content-Type"]?; do
			if test request.headers["Content-Type"] -eq "application/x-www-form-urlencoded"; do
				for param in !(split -s "&" request.content) do
					kv := !(split -s "=" param)
					if test #kv -eq 2; do
						key := kv[0]
						val := kv[1]
						val ~= "\\+" " "
						push val | search "(%[0-9a-fA-F]{2})+" | while pull -r escape_code; do
							code := new list<number>
							for num in !(split -s "%" escape_code)[1:] do
								code += ![parse_num -r 16 num]
							done
							val ~= -q escape_code ![btos code]
						done
						request.form[key] = val
					done
				done
			done
		done
	}
	
	/* Lähetys */
	
	function send_continue connection {
		response := "HTTP/1.1 100 Continue\r\n\r\n"
		connection.write response
	}
	
	/* Ohjaus */
	
	function handle connection {
		while true; do
			self.read connection request
			if push request.valid; do
				try do
					request.handle
				catch e
					request.send500 e
				done
			else
				break
			done
		done
	}
	
	function update {
		connection := ![self.socket.accept]
		date := "["..!(exec -l "date" "+%d.%m.%Y/%H:%M")[0].."]"
		print date.." Connection from "..connection.hostname.." ("..connection.ip..":"..connection.port..")."
		handler := ![thread { self.handle connection }]
		handler.start
	}
}

http_server port {
	http := new HttpServer
	http.port = port
	http.socket := ![server port]
	push http
}

record Request {
	valid : boolean = ![true]
	command : string
	path : string
	protocol : string
	headers : map<string>
	as_text : string
	content : string
	form : map<string>
	server : HttpServer
	connection : Socket
	
	function content_headers type length {
		content_headers := ""
		if test length -not_eq 0; do
			content_headers = "Content-Type: "..type.."\r\n"
			content_headers .= "Content-Length: "..length.."\r\n"
			content_headers .= "Accept-Ranges: bytes\r\n"
		done
		push content_headers
	}
	
	function create_headers content_headers status {
		headers := ""
		if test self.protocol -not_eq "HTTP/1.0"; do
			headers = "HTTP/1.1 "..status.."\r\n"
			headers .= "Server: http_server.roed\r\n"
			headers .= "Date: "
			headers .= !(exec -E "LC_TIME" "c.UTF-8" "date" -u "+%a, %b %d %Y %H:%M:%S GMT")[:-1]&"".."\r\n"
			headers .= content_headers
			headers .= "Connection: keep-alive\r\n"
			headers .= "\r\n"
		else
			headers = "HTTP/1.0 "..status.."\r\n"
			headers .= "Server: httpd.roed\r\n"
			headers .= content_headers
			headers .= "\r\n"
		done
		push headers
	}
	
	function send status data {
		response := ![self.create_headers ![self.content_headers "text/html; charset=utf-8" ![strsize data]] status]
		if test self.command -not_eq "HEAD"; do
			response .= data
		done
		self.connection.write response
	}
	
	function send_file mime name {
		response := ![self.create_headers ![self.content_headers mime ![file -l name]] "200 OK"]
		self.connection.write response
		if test self.command -not_eq "HEAD"; do
			self.connection.write -f name
		done
	}
	
	function redirect target {
		if test self.protocol -eq "HTTP/1.0"; do
			push "302 Found"
		else
			push "303 See Other"
		done | pull status_code
		data := [[<html>
		<head><title>]]..status_code..[[</title></head>
		<body><h1>]]..status_code..[[</h1>
		<p>The document is <a href="]]..target..[[">here</a>.</p>
		</body>
		</html>
		]]
		headers := ![self.content_headers "text/html; charset=utf-8" ![strsize data]].."Location: "..target.."\r\n"
		response := ![self.create_headers headers status_code]
		if test self.command -not_eq "HEAD"; do
			response .= data
		done
		self.connection.write response
	}
	
	function send403 {
		self.send "403 Forbidden" [[<html>
		<head><title>403 Forbidden</title></head>
		<body><h1>403 Forbidden</h1>
		<hr/>
		<p><i>http_server.röd</i></p></body>
		</html>]]
	}
	
	function send404 {
		self.send "404 Not found" [[<html>
		<head><title>404 Not found</title></head>
		<body><h1>404 Not found</h1><p>The resource you were looking for doesn't exist.</p>
		<hr/>
		<p><i>http_server.röd</i></p></body>
		</html>]]
	}
	
	function send412 {
		self.send "412 Precondition failed" ""
	}
	
	function send500 err {
		self.send "500 Internal server error" [[<html>
		<head><title>500 Internal server error</title></head>
		<body><h1>500 Internal server error</h1><p>Diagnostics:</p>
		<pre>]]..err.message..[[</pre>
		<pre>]]..!(err.stack | replace "<" "&lt;")&"\n"..[[</pre>
		<hr/>
		<p><i>http_server.röd</i></p></body>
		</html>]]
	}
	
	function handle {
		if push self.headers["If-Unmodified-Since"]?; do
			self.send412
			return
		done
		path := ![match "(/[^/]*)(/[^/]*)*" self.path]
		if test #path -eq 0; do path = ("/" "/" ""); done
		if push self.server.controllers[path[1]]?; do
			ctrl := self.server.controllers[path[1]]
			type := typeof ctrl
			for f in type.fields do
				for a in f.annotations do
					if push $(#a = 2 && a[0] = "HANDLE" && self.path =~ a[1]); do
						handler := ![f.get ctrl]
						handler self
						return
					done
				done
			done
			ctrl.handle self
		else
			self.send404
		done
	}
}

function @handle path {
	return ("HANDLE" path)
}

record Controller {
	handle : function
}

controller handler {
	ctrl := new Controller
	ctrl.handle = handler
	push ctrl
}